import { Vulnerability, VulnerabilityCategory, Severity, Location, Impact, Remediation, Environment } from '../types';
import { generateId, maskSecret } from '../utils/crypto';

export class VulnerabilityBuilder {
  private v: Partial<Vulnerability>;

  constructor() {
    this.v = {
      id: generateId(),
      timestamp: Date.now(),
      tags: [],
      confidence: 1.0,
      falsePositive: false,
      environment: 'unknown',
      context: '',
      evidence: '',
    };
  }

  setType(val: string) { this.v.type = val; return this; }
  setCategory(val: VulnerabilityCategory) { this.v.category = val; return this; }
  setSeverity(val: Severity) { this.v.severity = val; return this; }
  setTitle(val: string) { this.v.title = val; return this; }
  setDescription(val: string) { this.v.description = val; return this; }
  setLocation(val: Location) { this.v.location = val; return this; }
  setContext(val: string) { this.v.context = val; return this; }
  setEvidence(val: string, mask = true) { this.v.evidence = mask ? maskSecret(val) : val; return this; }
  setImpact(val: Impact) { this.v.impact = val; return this; }
  setRemediation(val: Remediation) { this.v.remediation = val; return this; }
  setConfidence(val: number) { this.v.confidence = Math.max(0, Math.min(1, val)); return this; }
  setCWE(val: string) { this.v.cweId = val; return this; }
  addTag(val: string) { this.v.tags = this.v.tags || []; this.v.tags.push(val); return this; }
  build(): Vulnerability { return this.v as Vulnerability; }
}

export function createSecretExposureVulnerability(
  secretType: string, service: string, maskedValue: string, location: Location, severity: Severity = 'critical'
): Vulnerability {
  return new VulnerabilityBuilder()
    .setType('secret_exposure').setCategory('secret_exposure').setSeverity(severity)
    .setTitle(`Exposed ${secretType} for ${service}`)
    .setDescription(`A ${secretType} for ${service} was found exposed in client-side code.`)
    .setLocation(location).setContext(`${service} ${secretType}`).setEvidence(maskedValue, false)
    .setImpact({ description: `Unauthorized access to ${service}`, exploitScenario: 'Attacker extracts and uses key', dataAtRisk: ['Account', 'Data'], businessImpact: 'Critical' })
    .setRemediation({ steps: ['Rotate key immediately', 'Remove from client code', 'Use server-side proxy'], references: ['https://owasp.org'], priority: 'immediate', effort: 'medium' })
    .setCWE('CWE-798').addTag('secret').addTag(service.toLowerCase()).build();
}

export function createMissingHeaderVulnerability(headerName: string, url: string, severity: Severity = 'medium'): Vulnerability {
  return new VulnerabilityBuilder()
    .setType('missing_security_header').setCategory('misconfiguration').setSeverity(severity)
    .setTitle(`Missing Security Header: ${headerName}`)
    .setDescription(`The ${headerName} header is missing.`)
    .setLocation({ type: 'header', url }).setContext('HTTP Headers').setEvidence(`${headerName} not present`)
    .setImpact({ description: 'Reduced security', exploitScenario: 'Various attacks', dataAtRisk: ['User data'], businessImpact: 'Medium' })
    .setRemediation({ steps: ['Add header to server config'], references: ['https://securityheaders.com'], priority: 'short-term', effort: 'low' })
    .addTag('headers').build();
}