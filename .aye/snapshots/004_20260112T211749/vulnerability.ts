/**
 * VaultGuard Vulnerability Model
 * Core vulnerability creation and management
 */

import type {
  Vulnerability,
  Severity,
  ScannerType,
  VulnerabilityLocation,
  VulnerabilityImpact,
  VulnerabilityRemediation,
  Environment,
} from '../types';
import { generateId } from '../utils/crypto-utils';

export interface CreateVulnerabilityParams {
  type: string;
  scannerType: ScannerType;
  severity: Severity;
  title: string;
  description: string;
  location: VulnerabilityLocation;
  impact?: Partial<VulnerabilityImpact>;
  remediation?: Partial<VulnerabilityRemediation>;
  environment?: Environment;
  cweId?: string;
  owaspCategory?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Create a new vulnerability object with defaults
 */
export function createVulnerability(params: CreateVulnerabilityParams): Vulnerability {
  return {
    id: generateId(),
    type: params.type,
    scannerType: params.scannerType,
    severity: params.severity,
    title: params.title,
    description: params.description,
    location: params.location,
    impact: {
      description: params.impact?.description ?? 'Potential security vulnerability detected',
      exploitScenario: params.impact?.exploitScenario ?? 'An attacker could exploit this vulnerability',
      dataAtRisk: params.impact?.dataAtRisk ?? [],
      cvssScore: params.impact?.cvssScore,
    },
    remediation: {
      steps: params.remediation?.steps ?? ['Review and fix the vulnerability'],
      codeExample: params.remediation?.codeExample,
      references: params.remediation?.references ?? [],
      estimatedEffort: params.remediation?.estimatedEffort ?? 'medium',
    },
    timestamp: Date.now(),
    environment: params.environment ?? 'unknown',
    cweId: params.cweId,
    owaspCategory: params.owaspCategory,
    metadata: params.metadata,
  };
}

/**
 * Get severity weight for sorting/scoring
 */
export function getSeverityWeight(severity: Severity): number {
  const weights: Record<Severity, number> = {
    critical: 5,
    high: 4,
    medium: 3,
    low: 2,
    info: 1,
  };
  return weights[severity];
}

/**
 * Compare vulnerabilities by severity
 */
export function compareVulnerabilities(a: Vulnerability, b: Vulnerability): number {
  return getSeverityWeight(b.severity) - getSeverityWeight(a.severity);
}

/**
 * Filter vulnerabilities by minimum severity
 */
export function filterBySeverity(
  vulnerabilities: Vulnerability[],
  minSeverity: Severity
): Vulnerability[] {
  const minWeight = getSeverityWeight(minSeverity);
  return vulnerabilities.filter((v) => getSeverityWeight(v.severity) >= minWeight);
}

/**
 * Group vulnerabilities by type
 */
export function groupByType(
  vulnerabilities: Vulnerability[]
): Map<string, Vulnerability[]> {
  const groups = new Map<string, Vulnerability[]>();
  
  for (const vuln of vulnerabilities) {
    const existing = groups.get(vuln.type) ?? [];
    existing.push(vuln);
    groups.set(vuln.type, existing);
  }
  
  return groups;
}

/**
 * Group vulnerabilities by scanner type
 */
export function groupByScannerType(
  vulnerabilities: Vulnerability[]
): Map<ScannerType, Vulnerability[]> {
  const groups = new Map<ScannerType, Vulnerability[]>();
  
  for (const vuln of vulnerabilities) {
    const existing = groups.get(vuln.scannerType) ?? [];
    existing.push(vuln);
    groups.set(vuln.scannerType, existing);
  }
  
  return groups;
}

/**
 * Count vulnerabilities by severity
 */
export function countBySeverity(
  vulnerabilities: Vulnerability[]
): Record<Severity, number> {
  const counts: Record<Severity, number> = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    info: 0,
  };
  
  for (const vuln of vulnerabilities) {
    counts[vuln.severity]++;
  }
  
  return counts;
}

/**
 * Calculate overall risk score (0-100)
 */
export function calculateRiskScore(vulnerabilities: Vulnerability[]): number {
  if (vulnerabilities.length === 0) return 0;
  
  const weights: Record<Severity, number> = {
    critical: 40,
    high: 25,
    medium: 10,
    low: 3,
    info: 1,
  };
  
  let score = 0;
  for (const vuln of vulnerabilities) {
    score += weights[vuln.severity];
  }
  
  // Cap at 100
  return Math.min(100, score);
}

/**
 * Get human-readable severity label
 */
export function getSeverityLabel(severity: Severity): string {
  const labels: Record<Severity, string> = {
    critical: 'Critical',
    high: 'High',
    medium: 'Medium',
    low: 'Low',
    info: 'Informational',
  };
  return labels[severity];
}

/**
 * Get severity color for UI
 */
export function getSeverityColor(severity: Severity): string {
  const colors: Record<Severity, string> = {
    critical: '#dc2626',
    high: '#ea580c',
    medium: '#ca8a04',
    low: '#2563eb',
    info: '#6b7280',
  };
  return colors[severity];
}